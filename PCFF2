local allowedPlaces = {
    [8206123457] = true,
    [8204899140] = true,
    [17541256525] = true
}

if not allowedPlaces[game.PlaceId] then
    game:GetService("Players").LocalPlayer:Kick("Wrong Game Bitch Nigga Check Supported Games")
end

-- Executor Check
local function BadExecutors()
    return string.match(getexecutorname(), "Solara")
       or string.match(getexecutorname(), "Zorara")
       or string.match(getexecutorname(), "Wind")
       or string.match(getexecutorname(), "Celery")
       or string.match(getexecutorname(), "Scythex")
       or string.match(getexecutorname(), "Nezur")
       or string.match(getexecutorname(), "Xeno")
end

local function GoodExecutors()
    return not BadExecutors()
end

if not LPH_OBFUSCATED then
    function LPH_JIT(Function) return Function end
    function LPH_JIT_MAX(Function) return Function end
    function LPH_NO_VIRTUALIZE(Function) return Function end
end

-- Anti-Cheat Bypass
LPH_NO_VIRTUALIZE(function()
    if hookmetamethod and not BadExecutors() then
        if game.PlaceId ~= 8206123457 and game.PlaceId == 8204899140 then
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local ReplicatedFirst = game:GetService("ReplicatedFirst")

            local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
            local ExpectedPath = LocalPlayer:GetFullName() .. ".PlayerScripts.PlayerScriptsLoader.PlayerModule.LocalScript"

            if ReplicatedFirst:FindFirstChild("LocalScript") then
                ReplicatedFirst:FindFirstChild("LocalScript"):Destroy()
                print(ExpectedPath)
            end

            local GarbageCollection = getgc(true)
            local Hooks = {}
            local FunctionList = {}
            local Handshake = nil

            local Iterator = table.foreach

            local function IsACItem(Function)
                return debug.info(Function, "s") == ExpectedPath
            end

            local function ACLine(Function)
                return debug.info(Function, "l")
            end

            Iterator(GarbageCollection, function(_, Item)
                if type(Item) == "function" and IsACItem(Item) then
                    table.insert(FunctionList, Item)
                end
            end)

            Iterator(GarbageCollection, function(_, Function)
                if type(Function) == "function" and IsACItem(Function) then
                    local Line = ACLine(Function)
                    if table.find({42, 51, 61}, Line) then
                        hookfunction(Function, function() end)
                    end
                end
            end)

            Iterator(FunctionList, function(_, Function)
                if type(Function) == "function" and debug.getinfo(Function).numparams == 7 then
                    Handshake = Function
                end
            end)

            task.wait()

            Hooks.debug_info = hookfunction(debug.info, function(...)
                local Args = {...}
                if not checkcaller() and (Args[1] == 2) and (Args[2] == "s") then
                    return "LocalScript"
                end
                return Hooks.debug_info(...)
            end)

            Hooks.__call = hookfunction(Handshake, function(...)
                local Args = {...}
                if Args[2] == 655 and Args[3] == 775 and Args[4] == 724 and Args[5] == 633 and Args[6] == 891 then
                    return Hooks.__call(...)
                elseif Args[2] == 760 and Args[3] == 760 and Args[4] == 771 and Args[5] == 665 and Args[6] == 898 then
                    return Hooks.__call(...)
                elseif Args[2] == 660 and Args[3] == 759 and Args[4] == 751 and Args[5] == 863 and Args[6] == 771 then
                    return Hooks.__call(...)
                end
            end)
        end
        AC_BYPASS = true
    end
end)()

if AC_BYPASS == true then
    print("Celaris Injected")
else
    print("Celaris failed to bypass!")
end



local Player = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local keysus = "RightControl"
local Magnets = false
local ShowHitbox = false
local Range = 10
local autoCatchEnabled = false
local catchDelay = 0.01
local maxAutoCatchDistance = 10 -- default value
local autoSwatEnabled = false
local swatDelay = 0.01
local maxAutoSwatDistance = 10
local autoQBEnabled = false
local resetAfterCatchEnabled = false
local resetAfterCatchDelay = 1
local autoRushEnabled = false
local autoRushDelay = 0.5
local lowerGraphicsEnabled = false

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local toggleBlockReach = false
local blockReachAmount = 3 -- default slider value
local originalSize = Vector3.new(0.8500000238418579, 5, 1.5)
local blockPartName = "BlockPart"

local function applyBlockReach()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local blockPart = char:FindFirstChild(blockPartName)
	if blockPart and blockPart:IsA("BasePart") then
		blockPart.Size = Vector3.new(2.5, originalSize.Y, originalSize.Z + blockReachAmount)
	end
end

-- Function to reset block reach
local function resetBlockReach()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local blockPart = char:FindFirstChild(blockPartName)
	if blockPart and blockPart:IsA("BasePart") then
		blockPart.Size = originalSize
	end
end

-- Character reset handling (reset-proof feature)
LocalPlayer.CharacterAdded:Connect(function()
	if toggleBlockReach then
		task.wait(1) -- wait for the character to fully load
		applyBlockReach()
	end
end)



local tackleReachEnabled = false

local autoJumpEnabled = false
local jumpDelay = 0.01
local jumpMaxDistance = 10

local originalMaterials = {}
local stadiumOriginalCFrame = nil
local ballTrailEnabled = false

local pullEnabled = false
local pullDistance = 10
local pullDelayEnabled = false
local pullDelayAmount = 0.1
local lastPossessTime = 0

local noJumpCooldownEnabled = false
local lastFakeJumpTime = 0
local jumpCooldownWait = 0.3
local jumpConnection

local UseMagnetDelay = false
local MagnetDelay = 0.01 -- Default value
local HitboxColor = Color3.fromRGB(178, 178, 178) -- Default color
local HitboxTransparency = 0.8 -- Default transparency
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()

Player.CharacterAdded:Connect(function(char)
    Character = char
end)

-- Walkspeed and No Move Restrictions Variable
local walkSpeedEnabled = false
local walkSpeedValue = 20  -- Default WalkSpeed
local jumpPowerEnabled = false
local jumpPowerValue = 50  -- Default JumpPower
local noMoveRestrictions = false


-- // Feature Toggles and Sliders
local walkSpeedEnabled = false
local walkSpeedValue = 20

-- Variables
local workspace = game:GetService("Workspace")
local scrambleWall = workspace:WaitForChild("ScrambleWall") -- Assumes ScrambleWall exists in workspace
local toggle = false
local canCollideCheck = true -- Whether CanCollide should be checked

-- Function to disable CanCollide
local function disableCanCollide()
    if scrambleWall and scrambleWall:IsA("BasePart") then
        if scrambleWall.CanCollide then
            scrambleWall.CanCollide = false
        end
    end
end

local rainWasInitiallyEnabled = false
local snowWasInitiallyEnabled = false
local rainSoundWasPlaying = false

local jumpPowerEnabled = false
local jumpPowerValue = 50

local noMoveRestrictions = false
local autoCaptainActive = false

local function pullToFootball()
    task.spawn(function()
        while pullEnabled do
            task.wait(0.1)

            local character = Player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then continue end

            local hasFootball = character:FindFirstChild("Football") ~= nil
            if hasFootball then
                lastPossessTime = tick()
            elseif tick() - lastPossessTime < 1 then
                continue -- wait 1 sec after losing football
            end

            local closestFootball
            local shortestDistance = pullDistance

            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj.Name == "Football" then
                    local possessed = false
                    local current = obj.Parent
                    while current do
                        if current:FindFirstChild("Humanoid") then
                            possessed = true
                            break
                        end
                        current = current.Parent
                    end

                    if not possessed then
                        local dist = (character.HumanoidRootPart.Position - obj.Position).Magnitude
                        if dist < shortestDistance then
                            shortestDistance = dist
                            closestFootball = obj
                        end
                    end
                end
            end

            if closestFootball then
                if pullDelayEnabled then task.wait(pullDelayAmount) end
                character:MoveTo(closestFootball.Position)
            end
        end
    end)
end

-- // Apply Settings Function
local function applySettings()
    local character = game:GetService("Players").LocalPlayer.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character.Humanoid

        -- WalkSpeed logic
        if walkSpeedEnabled then
            if humanoid.WalkSpeed == 0 and not noMoveRestrictions then
                -- Don't apply WalkSpeed while restricted
                return
            end
            humanoid.WalkSpeed = walkSpeedValue
        elseif noMoveRestrictions and humanoid.WalkSpeed == 0 then
            humanoid.WalkSpeed = 20 -- Default speed fix when restricted but bypass is on
        else
            humanoid.WalkSpeed = 20
        end

        -- JumpPower logic
        if jumpPowerEnabled then
            humanoid.JumpPower = jumpPowerValue
        else
            humanoid.JumpPower = 50
        end
    end
end

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local function setupNoJumpCooldown()
    if typeof(jumpConnection) == "RBXScriptConnection" then
        jumpConnection:Disconnect()
        jumpConnection = nil
    end

    if noJumpCooldownEnabled then
        jumpConnection = UserInputService.JumpRequest:Connect(function()
            local character = LocalPlayer.Character
            local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")

            if not humanoid then return end

            task.wait()

            if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                local currentTime = tick()
                if currentTime - lastFakeJumpTime >= jumpCooldownWait then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    lastFakeJumpTime = currentTime
                end
            end
        end)
    end
end


-- Function to find the player holding the football
local function findFootballHolder()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Football") then
            return player
        end
    end
    return nil
end

local function predictPosition(targetHrp, timeAhead)
    local targetVelocity = targetHrp.Velocity
    return targetHrp.Position + (targetVelocity * timeAhead)
end

local function autoRush(delay)
    while autoRushEnabled do
        local footballHolder = findFootballHolder()
        if footballHolder then
            local character = LocalPlayer.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            local targetHrp = footballHolder.Character and footballHolder.Character:FindFirstChild("HumanoidRootPart")

            if hrp and targetHrp then
                local predictedPosition = predictPosition(targetHrp, delay)
                if predictedPosition.Magnitude > 0 then
                    character.Humanoid:MoveTo(predictedPosition)
                end
            end
        else
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid:Move(Vector3.new(0, 0, 0), true)
            end
        end
        task.wait(0.1)
    end
end


-- // Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/exlehskee/Celaris/refs/heads/main/sdadas"))()
local Main = Library:Create("Celaris", "Football Fusion")

local CatchingTab = Main:CreateSection("Catching")
local AutomaticsTab = Main:CreateSection("Automatics")
local PlayersTab = Main:CreateSection("Player")
local VisualsTab = Main:CreateSection("Visuals")
local SettingsTab = Main:CreateSection("Settings")

-- Catching Tab
CatchingTab:CreateLabel("Catching")
CatchingTab:CreateToggle("Ball Magnets", function(value)
    Magnets = value
end)

CatchingTab:CreateToggle("Show Hitbox", function(value)
    ShowHitbox = value
end)

CatchingTab:CreateSlider(7, 20, "Magnets Size", function(value)
    Range = value
    for _, v in workspace:GetChildren() do
        if v.Name == "Football" and v:IsA("BasePart") then
            local sphere = v:FindFirstChild("RangeSphere")
            if sphere then
                sphere.Size = Vector3.new(Range, Range, Range)
            end
        end
    end
end)

CatchingTab:CreateToggle("Magnet Delay", function(value)
    UseMagnetDelay = value
end)

CatchingTab:CreateTextBox("Delay Amount", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        MagnetDelay = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Magnet Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateLabel("CFrame Pull")
CatchingTab:CreateToggle("Enabled", function(value)
    pullEnabled = value
    if value then
        pullToFootball()
    end
end)

CatchingTab:CreateSlider(5, 15, "Pull Distance", function(value)
    pullDistance = value
end)

CatchingTab:CreateToggle("Pull Delay", function(value)
    pullDelayEnabled = value
end)

CatchingTab:CreateTextBox("Delay", "Delay (0.01 - 1)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        pullDelayAmount = num
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Pull Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)


CatchingTab:CreateLabel("Hitbox Settings")

CatchingTab:CreateTextBox("Hitbox Color", "RGB CODE", function(v)
    local r, g, b = v:match("(%d+),%s*(%d+),%s*(%d+)")
    r, g, b = tonumber(r), tonumber(g), tonumber(b)

    if r and g and b and r <= 255 and g <= 255 and b <= 255 then
        HitboxColor = Color3.fromRGB(r, g, b)

        -- Update all current spheres
        for _, football in workspace:GetChildren() do
            if football.Name == "Football" and football:IsA("BasePart") then
                local sphere = football:FindFirstChild("RangeSphere")
                if sphere then
                    sphere.Color = HitboxColor
                end
            end
        end

        -- Notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Hitbox Color Updated",
                Text = string.format("New Color: RGB(%d, %d, %d)", r, g, b),
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Input",
                Text = "Please enter 3 numbers from 0-255 separated by commas",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateTextBox("Hitbox Transparency", "0 - 0.9", function(v)
    local num = tonumber(v)

    if num and num >= 0 and num <= 0.9 then
        HitboxTransparency = num

        -- Update all current spheres
        for _, football in workspace:GetChildren() do
            if football.Name == "Football" and football:IsA("BasePart") then
                local sphere = football:FindFirstChild("RangeSphere")
                if sphere then
                    sphere.Transparency = ShowHitbox and HitboxTransparency or 1
                end
            end
        end

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Transparency Updated",
                Text = "New Transparency: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Input",
                Text = "Enter a number between 0 and 0.9",
                Duration = 3
            })
        end)
    end
end)


-- // Automatics Tab

AutomaticsTab:CreateLabel("Auto Catch")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoCatchEnabled = value 
end)
AutomaticsTab:CreateTextBox("Catch Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 3 then
        catchDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Catch Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 3",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateSlider(10, 30, "Max Distance", function(value)
    maxAutoCatchDistance = value
end)

AutomaticsTab:CreateLabel("Auto Swat")

AutomaticsTab:CreateToggle("Enabled", function(value)
    autoSwatEnabled = value 
end)
AutomaticsTab:CreateTextBox("Swat Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 3 then
        swatDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Swat Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 3",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateSlider(10, 30, "Max Distance", function(value)
    maxAutoSwatDistance = value
end)

AutomaticsTab:CreateLabel("Auto Jump")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoJumpEnabled = value 
end)
AutomaticsTab:CreateTextBox("Jump Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        jumpDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Jump Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateSlider(10, 30, "Max Distance", function(value)
    jumpMaxDistance = value
end)


AutomaticsTab:CreateLabel("Reset After Catch")

AutomaticsTab:CreateToggle("Enabled", function(value)
    resetAfterCatchEnabled = value 
end)

AutomaticsTab:CreateTextBox("RAC Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 2 then
        catchDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "RAC Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 2",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateLabel("Auto QB")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoQBEnabled = value 
end)

AutomaticsTab:CreateLabel("Auto Rush")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoRushEnabled = value
    if value then
        spawn(function()
            autoRush(autoRushDelay)
        end)
    end
end)

AutomaticsTab:CreateTextBox("Rush Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        autoRushDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto-Rush Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)


-- Player Tab:

PlayersTab:CreateLabel("Player")
PlayersTab:CreateToggle("WalkSpeed", function(value)
    walkSpeedEnabled = value
end)

PlayersTab:CreateSlider(20, 23, "JumpPower Amount", function(value)
    walkSpeedValue = value
end)

PlayersTab:CreateToggle("JumpPower", function(value)
    jumpPowerEnabled = value
end)

PlayersTab:CreateSlider(50, 60, "JumpPower Amount", function(value)
    jumpPowerValue = value
end)

PlayersTab:CreateLabel("Defense")

PlayersTab:CreateToggle("Tackle Reach", function(value)
    tackleReachEnabled = value
end)

PlayersTab:CreateToggle("Block Reach", function(value)
	toggleBlockReach = value
	if toggleBlockReach then
		applyBlockReach()
	else
		resetBlockReach()
	end
end)

-- Slider
PlayersTab:CreateSlider(3, 10, "Reach Amount", function(value)
	blockReachAmount = value
	if toggleBlockReach then
		applyBlockReach()
	end
end)

PlayersTab:CreateLabel("Miscellaneous")

PlayersTab:CreateToggle("No Move Restrictions", function(value)
    noMoveRestrictions = value
end)

PlayersTab:CreateToggle("No Jump Cooldown", function(value)
    noJumpCooldownEnabled = value
    setupNoJumpCooldown()
end)


-- VisualsTab

VisualsTab:CreateLabel("Game Visuals")
VisualsTab:CreateToggle("Better FPS", function(value)
    lowerGraphicsEnabled = value
    handleGraphics(Player.Character, value)
end)

VisualsTab:CreateToggle("Hide Stadium", function(value)
    local stadium = workspace:FindFirstChild("Models").Stadium
    if stadium and stadium:IsA("Model") then
        if stadium.PrimaryPart then
            if value then
                if not stadiumOriginalCFrame then
                    stadiumOriginalCFrame = stadium:GetPrimaryPartCFrame()
                end
                stadium:SetPrimaryPartCFrame(stadium.PrimaryPart.CFrame * CFrame.new(0, -500, 0))
            else
                if stadiumOriginalCFrame then
                    stadium:SetPrimaryPartCFrame(stadiumOriginalCFrame)
                end
            end
        end
    end
end)

VisualsTab:CreateLabel("Weather Visuals")
VisualsTab:CreateToggle("Remove Rain", function(value)
    local weather = workspace:FindFirstChild("SkyWeather")
    local sounds = workspace:FindFirstChild("Sounds")

    -- Handle Rain Particles
    if weather and weather:IsA("BasePart") then
        local rain = weather:FindFirstChild("Rain")
        if rain and rain:IsA("ParticleEmitter") then
            if value then
                rainWasInitiallyEnabled = rain.Enabled
                if rain.Enabled then
                    rain.Enabled = false
                end
            else
                if rainWasInitiallyEnabled then
                    rain.Enabled = true
                end
            end
        end
    end

    -- Handle Rain Sound
    if sounds and sounds:FindFirstChild("Rain") then
        local rainSound = sounds:FindFirstChild("Rain")
        if value then
            rainSoundWasPlaying = rainSound.IsPlaying
            if rainSound:IsA("Sound") and rainSound.IsPlaying then
                rainSound:Stop()
            end
        else
            if rainSoundWasPlaying and rainSound:IsA("Sound") and not rainSound.IsPlaying then
                rainSound:Play()
            end
        end
    end
end)

VisualsTab:CreateToggle("Remove Snow", function(value)
    local weather = workspace:FindFirstChild("SkyWeather")
    if weather and weather:IsA("BasePart") then
        local snow = weather:FindFirstChild("Snow")
        if snow and snow:IsA("ParticleEmitter") then
            if value then
                -- Toggle ON: remove snow if it was enabled
                snowWasInitiallyEnabled = snow.Enabled
                if snow.Enabled then
                    snow.Enabled = false
                end
            else
                -- Toggle OFF: only re-enable if it was originally on
                if snowWasInitiallyEnabled then
                    snow.Enabled = true
                end
            end
        end
    end
end)

VisualsTab:CreateLabel("Miscellaneous")
VisualsTab:CreateToggle("Remove QB Boundaries", function(value)
    toggle = value
    print("ScrambleWall CanCollide check: " .. (toggle and "ON" or "OFF"))
end)
-- Source



task.spawn(function()
    while true do
        task.wait()

        if autoCatchEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= maxAutoCatchDistance then
                task.wait(catchDelay)

                local targetKey = Enum.KeyCode.C
                game:GetService("VirtualInputManager"):SendKeyEvent(true, targetKey, false, game)
                task.wait(0.1)
                game:GetService("VirtualInputManager"):SendKeyEvent(false, targetKey, false, game)
            end
        end
    end
end)


-- // Remove the sphere when the football disappears from the workspac

task.spawn(function()
    while true do
        task.wait()

        if autoSwatEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= maxAutoSwatDistance then
                task.wait(swatDelay)

                local vim = game:GetService("VirtualInputManager")
                vim:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                task.wait(0.1)
                vim:SendKeyEvent(false, Enum.KeyCode.R, false, game)
            end
        end
    end
end)

-- // Remove the sphere when the football disappears from the workspac

task.spawn(function()
    while true do
        task.wait()

        if autoJumpEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= jumpMaxDistance then
                task.wait(jumpDelay)

                local vim = game:GetService("VirtualInputManager")
                vim:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                task.wait(0.1)
                vim:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
            end
        end
    end
end)

local lastHadFootball = false

task.spawn(function()
    while true do
        task.wait(0.1)

        if resetAfterCatchEnabled then
            local char = Player.Character
            if char and char:FindFirstChild("Football") and not lastHadFootball then
                lastHadFootball = true
                task.wait(resetAfterCatchDelay)

                if char:FindFirstChild("Humanoid") then
                    char.Humanoid.Health = 0
                end
            elseif char and not char:FindFirstChild("Football") then
                lastHadFootball = false
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()

        if autoQBEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Humanoid") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist <= 50 and dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest then
                char.Humanoid:MoveTo(closest.Position)
            end
        end
    end
end)


task.spawn(function()
    while true do
        task.wait(0.1)

        if not tackleReachEnabled then continue end

        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        local closest, closestDist = nil, math.huge

        for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild("Football") then
                local targetHRP = plr.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    local dist = (hrp.Position - targetHRP.Position).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closest = targetHRP
                    end
                end
            end
        end

        if closest and closestDist <= 5 then
            local originalPos = hrp.CFrame
            for _ = 1, 5 do
                hrp.CFrame = closest.CFrame
                task.wait(0.01)
                hrp.CFrame = originalPos
                task.wait(0.01)
            end
        end
    end
end)


-- // Magnet loop
task.spawn(function()
    while true do
        task.wait()

        if not Magnets then continue end
        if not Character or not Character:FindFirstChild("CatchRight") or not Character:FindFirstChild("CatchLeft") then continue end

        for _, v in workspace:GetChildren() do
            if v.Name == "Football" and v:IsA("BasePart") and not v.Anchored and v.Parent == workspace then
                -- Add sphere if missing
                local sphere = v:FindFirstChild("RangeSphere")
                if not sphere then
                    sphere = Instance.new("Part")
                    sphere.Name = "RangeSphere"
                    sphere.Shape = Enum.PartType.Ball
                    sphere.Size = Vector3.new(Range, Range, Range)
                    sphere.Color = HitboxColor
                    sphere.Transparency = ShowHitbox and HitboxTransparency or 1
                    sphere.CanCollide = false
                    sphere.Anchored = true
                    sphere.Material = Enum.Material.Neon
                    sphere.Position = v.Position
                    sphere.Parent = v

                    task.spawn(function()
                        while sphere.Parent == v and v.Parent == workspace do
                            task.wait()
                            sphere.CFrame = v.CFrame
                        end
                    end)
                end

                -- Distance check
                local distRight = (Character["CatchRight"].Position - sphere.Position).magnitude
                local distLeft = (Character["CatchLeft"].Position - sphere.Position).magnitude

                if distRight <= Range or distLeft <= Range then
                    task.spawn(function()
                        if UseMagnetDelay then
                            task.wait(MagnetDelay)
                        end
                        firetouchinterest(Character["CatchRight"], v, 0)
                        firetouchinterest(Character["CatchLeft"], v, 0)
                        firetouchinterest(Character["CatchRight"], v, 1)
                        firetouchinterest(Character["CatchLeft"], v, 1)
                    end)
                end
            end
        end
    end
end)

game:GetService("RunService").Heartbeat:Connect(function()
    if toggle and canCollideCheck then
        disableCanCollide()
    end
end)

workspace.ChildRemoved:Connect(function(child)
    if child.Name == "Football" and child:IsA("BasePart") then
        local sphere = child:FindFirstChild("RangeSphere")
        if sphere then
            sphere:Destroy()
        end
    end
end)



game:GetService("RunService").Heartbeat:Connect(function()
    if walkSpeedEnabled or jumpPowerEnabled or noMoveRestrictions then
        applySettings()
    end
end)

function handleGraphics(char, low)
    if not char then return end

    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            if low then
                -- Store original material if not already stored
                if not originalMaterials[part] then
                    originalMaterials[part] = part.Material
                end
                part.Material = Enum.Material.SmoothPlastic
            else
                -- Revert to original material if it was stored
                if originalMaterials[part] then
                    part.Material = originalMaterials[part]
                end
            end
        end
    end

    -- If turning off, clear the material cache
    if not low then
        originalMaterials = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if walkSpeedEnabled or jumpPowerEnabled or noMoveRestrictions then
        applySettings()
    end
end)


local toggleKey = Enum.KeyCode.RightControl -- You can change this to any key

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local isEnabled = true  -- Start with the UI element enabled

-- Assuming the "name" is a GUI element in CoreGui
local guiElement = CoreGui:WaitForChild("name")

-- Function to toggle visibility
local function toggleVisibility()
    isEnabled = not isEnabled  -- Toggle the boolean value
    guiElement.Enabled = isEnabled  -- Set the visibility based on the state
end

-- Detect RightControl key press to toggle visibility
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if Enum.KeyCode[keysus] and input.KeyCode == Enum.KeyCode[keysus] then
        toggleVisibility()
    end
end)

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

-- Function to apply the drag system
local function applyDragSystem()
	wait(1) -- Delay so everything is loaded

	for _, gui in pairs(CoreGui:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "name" then
			local MainLib = gui:FindFirstChild("MainLib")
			if MainLib then
				local dragging = false
				local dragStart, startPos

				local function update(input)
					local delta = input.Position - dragStart
					MainLib.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
				end

				MainLib.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragging = true
						dragStart = input.Position
						startPos = MainLib.Position

						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragging = false
							end
						end)
					end
				end)

				UserInputService.InputChanged:Connect(function(input)
					if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
						update(input)
					end
				end)
			end
		end
	end
end

applyDragSystem()

SettingsTab:CreateLabel("Settings")
SettingsTab:CreateTextBox("UI Keybind", "Key Here", function(v)
    -- Capitalize the first letter of each word (preserves proper Enum.KeyCode formatting)
    local formatted = v:gsub("^%l", string.upper):gsub("(%u)(%u+)", function(a, b)
        return a .. b:lower()
    end)

    if Enum.KeyCode[formatted] then
        keysus = formatted
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Keybind Updated",
                Text = "New Keybind: " .. formatted,
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Key",
                Text = "Please enter a valid KeyCode (e.g. RightShift, G, LeftControl)",
                Duration = 4
            })
        end)
    end
end)
